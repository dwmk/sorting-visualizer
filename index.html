<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorting Algorithms Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-100 p-6">
  <div class="max-w-4xl mx-auto">
    <h1 class="text-3xl font-bold text-center mb-6">Sorting Algorithms Visualizer</h1>

    <div class="flex flex-col md:flex-row gap-4 mb-4">
      <input type="text" id="inputData" placeholder="Enter numbers e.g. 1, 5, 35, -29, 20, 0, 0.123" class="w-full p-2 border rounded" />
      <input type="file" id="fileInput" class="p-2" />
      <select id="algorithm" class="p-2 border rounded">
        <option value="bubble">Bubble Sort</option>
        <option value="selection">Selection Sort</option>
        <option value="insertion">Insertion Sort</option>
        <option value="bucket">Bucket Sort</option>
        <option value="merge">Merge Sort</option>
        <option value="quick">Quick Sort</option>
      </select>
      <button onclick="startSort()" class="bg-blue-500 text-white px-4 py-2 rounded">Sort</button>
    </div>

    <!-- Speed control & manual step buttons -->
    <div class="bg-white p-3 rounded shadow flex flex-col md:flex-row md:items-center md:gap-4 mb-4">
      <div class="flex items-center gap-4">
        <label class="font-medium whitespace-nowrap">Speed:</label>
        <input type="range" id="speedSlider" min="10" max="1000" value="550" step="10" class="w-48 accent-blue-500" />
        <span id="speedValue" class="text-gray-600 text-sm whitespace-nowrap">Speed: 1.0x</span>
      </div>
      <div class="flex justify-center gap-3 mt-3 md:mt-0 flex-wrap">
        <button id="stepBack" class="bg-gray-400 text-white px-3 py-1 rounded">⟸ Step Back</button>
        <button id="playPause" class="bg-green-500 text-white px-4 py-1 rounded">▶ Play</button>
        <button id="stepForward" class="bg-gray-600 text-white px-3 py-1 rounded">Step Forward ⟹</button>
      </div>
    </div>

    <div id="visualization" class="flex items-end space-x-1 h-64 bg-white border rounded p-2 overflow-x-auto"></div>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
      <div class="bg-white p-4 rounded shadow">
        <h2 class="text-lg font-semibold mb-2">Data Statistics</h2>
        <p><strong>Count:</strong> <span id="stat-count"></span></p>
        <p><strong>Min:</strong> <span id="stat-min"></span></p>
        <p><strong>Max:</strong> <span id="stat-max"></span></p>
        <p><strong>Average:</strong> <span id="stat-avg"></span></p>
      </div>
      <div class="bg-white p-4 rounded shadow">
        <h2 class="text-lg font-semibold mb-2">Sort Progress</h2>
        <p><strong>Algorithm:</strong> <span id="stat-algo"></span></p>
        <p><strong>Iterations:</strong> <span id="stat-iter"></span></p>
        <p><strong>Current Index:</strong> <span id="stat-index"></span></p>
        <p><strong>Pivot:</strong> <span id="stat-pivot"></span></p>
      </div>
    </div>
  </div>

<script>
  let data = [];
  let stats = { iter: 0, index: '', pivot: '' };
  let delay = 500; // default 1.0x
  let history = [];
  let historyIndex = -1;
  let isPlaying = false;
  let playInterval = null;

  const fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', function (e) {
    const reader = new FileReader();
    reader.onload = () => {
      document.getElementById('inputData').value = reader.result;
    };
    reader.readAsText(e.target.files[0]);
  });

  // --- Discrete Speed Slider ---
  const speedSlider = document.getElementById('speedSlider');
  const speedValue = document.getElementById('speedValue');

  // Discrete speed levels
  const speedSteps = [0.5, 1.0, 1.25, 1.5, 2.0, 4.0];
  let currentSpeed = 1.0;

  function applySpeed(speed) {
    currentSpeed = speed;
    speedValue.textContent = `Speed: ${speed.toFixed(2)}x`;
    delay = 500 / speed; // smaller delay → faster
    if (isPlaying) {
      // reapply immediately without resetting playback
      clearInterval(playInterval);
      playHistory();
    }
  }

  // Convert slider position → nearest discrete step
  speedSlider.setAttribute('min', 0);
  speedSlider.setAttribute('max', speedSteps.length - 1);
  speedSlider.setAttribute('step', 1);
  speedSlider.value = 1; // default 1.0x

  speedSlider.addEventListener('input', () => {
    const idx = parseInt(speedSlider.value);
    const newSpeed = speedSteps[idx];
    applySpeed(newSpeed);
  });

  const playPauseBtn = document.getElementById('playPause');
  playPauseBtn.addEventListener('click', () => {
    if (!history.length) return; // do nothing if no history
    isPlaying = !isPlaying;
    updatePlayButton();
    if (isPlaying) playHistory();
    else clearInterval(playInterval);
  });

  document.getElementById('stepForward').addEventListener('click', () => {
    clearInterval(playInterval);
    isPlaying = false;
    updatePlayButton();
    if (historyIndex < history.length - 1) {
      historyIndex++;
      drawFrame(historyIndex);
    }
  });

  document.getElementById('stepBack').addEventListener('click', () => {
    clearInterval(playInterval);
    isPlaying = false;
    updatePlayButton();
    if (historyIndex > 0) {
      historyIndex--;
      drawFrame(historyIndex);
    }
  });

  function updatePlayButton() {
    playPauseBtn.textContent = isPlaying ? '⏸ Pause' : '▶ Play';
    playPauseBtn.className = isPlaying
      ? 'bg-yellow-500 text-white px-4 py-1 rounded'
      : 'bg-green-500 text-white px-4 py-1 rounded';
  }

  function parseInput() {
    return document.getElementById('inputData').value
      .split(',')
      .map(x => parseFloat(x.trim()))
      .filter(x => !isNaN(x));
  }

  function updateStats(data) {
    if (!data.length) return;
    document.getElementById('stat-count').innerText = data.length;
    document.getElementById('stat-min').innerText = Math.min(...data);
    document.getElementById('stat-max').innerText = Math.max(...data);
    document.getElementById('stat-avg').innerText = (data.reduce((a, b) => a + b, 0) / data.length).toFixed(2);
  }

  function updateSortStats(algo, index = '', pivot = '') {
    stats.iter++;
    stats.index = index;
    stats.pivot = pivot;
    document.getElementById('stat-algo').innerText = algo;
    document.getElementById('stat-iter').innerText = stats.iter;
    document.getElementById('stat-index').innerText = index;
    document.getElementById('stat-pivot').innerText = pivot;
  }

function draw(data, highlighted = []) {
  updateStats(data);
  const container = document.getElementById('visualization');
  container.innerHTML = '';

  if (!data || data.length === 0) return;

  const max = Math.max(...data.map(Math.abs), 1);

  data.forEach((val, i) => {
    const heightPercent = (Math.abs(val) / max) * 100;
    const isHighlighted = highlighted.includes(i);

    // Wrapper (bar + label)
    const barWrapper = document.createElement('div');
    barWrapper.className = 'flex items-end justify-center relative';
    barWrapper.style.width = '28px';
    barWrapper.style.height = '80%';
    barWrapper.style.minHeight = '0';
    barWrapper.style.position = 'relative';

    // Actual bar
    const bar = document.createElement('div');
    bar.style.height = `${heightPercent}%`;
    bar.style.width = '100%';
    bar.classList.add('rounded', 'transition-all', 'duration-100');
    if (isHighlighted) bar.classList.add('bg-red-500');
    else bar.classList.add('bg-blue-500');
    bar.setAttribute('title', String(val));

    // Label — position dynamically based on bar height
    const label = document.createElement('div');
    label.textContent = val;
    label.className = 'px-1.5 py-0.5 text-xs rounded font-mono text-center select-none shadow-sm absolute';
    label.style.left = '50%';
    label.style.transform = 'translateX(-50%)';
    label.style.bottom = `${heightPercent}%`; // <-- key: align with top of bar
    label.style.marginBottom = '4px'; // small gap above bar
    label.style.pointerEvents = 'none';

    // Subtle background tint
    if (isHighlighted) {
      label.style.backgroundColor = 'rgba(220,38,38,0.12)';
      label.style.color = '#7f1d1d';
    } else {
      label.style.backgroundColor = 'rgba(59,130,246,0.12)';
      label.style.color = '#1e40af';
    }

    barWrapper.appendChild(bar);
    barWrapper.appendChild(label);
    container.appendChild(barWrapper);
  });
}



  // --- Proper frame drawing + synchronized stats ---
  function drawFrame(index) {
    const frame = history[index];
    if (!frame) return;
    draw(frame.data, frame.highlighted);
    const { algo, iter, idx, pivot } = frame.stats || {};
    document.getElementById('stat-algo').innerText = algo || '';
    document.getElementById('stat-iter').innerText = iter || '';
    document.getElementById('stat-index').innerText = idx ?? '';
    document.getElementById('stat-pivot').innerText = pivot ?? '';
  }

  function recordState(arr, highlighted, algo = '', index = '', pivot = '') {
    // store snapshot including current stat
    history.push({
      data: [...arr],
      highlighted: [...highlighted],
      stats: { algo, iter: stats.iter, idx: index, pivot },
    });
  }

  // --- Sorting algorithms build history ---
  async function bubbleSort(arr) {
    let a = [...arr];
    stats.iter = 0;
    history = [];
    for (let i = 0; i < a.length; i++) {
      for (let j = 0; j < a.length - i - 1; j++) {
        updateSortStats('Bubble Sort', j);
        if (a[j] > a[j + 1]) [a[j], a[j + 1]] = [a[j + 1], a[j]];
        recordState(a, [j, j + 1], 'Bubble Sort', j);
      }
    }
    return a;
  }

  async function selectionSort(arr) {
    let a = [...arr];
    stats.iter = 0;
    history = [];
    for (let i = 0; i < a.length; i++) {
      let min = i;
      for (let j = i + 1; j < a.length; j++) {
        updateSortStats('Selection Sort', j);
        if (a[j] < a[min]) min = j;
        recordState(a, [i, j], 'Selection Sort', j);
      }
      [a[i], a[min]] = [a[min], a[i]];
      recordState(a, [i, min], 'Selection Sort', i);
    }
    return a;
  }

  async function insertionSort(arr) {
    let a = [...arr];
    stats.iter = 0;
    history = [];
    for (let i = 1; i < a.length; i++) {
      let key = a[i];
      let j = i - 1;
      updateSortStats('Insertion Sort', i);
      while (j >= 0 && a[j] > key) {
        a[j + 1] = a[j];
        recordState(a, [j, j + 1], 'Insertion Sort', j);
        j--;
      }
      a[j + 1] = key;
      recordState(a, [j + 1], 'Insertion Sort', j + 1);
    }
    return a;
  }

  async function bucketSort(arr) {
    let a = [...arr];
    stats.iter = 0;
    history = [];
    const max = Math.max(...a);
    const min = Math.min(...a);
    const bucketCount = Math.floor(Math.sqrt(a.length));
    const buckets = Array.from({ length: bucketCount }, () => []);

    for (let i = 0; i < a.length; i++) {
      const idx = Math.floor(((a[i] - min) / (max - min + 1)) * bucketCount);
      buckets[Math.min(idx, bucketCount - 1)].push(a[i]);
      updateSortStats('Bucket Sort', i);
      recordState(a, [i], 'Bucket Sort', i);
    }
    a = [].concat(...buckets.map(b => b.sort((x, y) => x - y)));
    recordState(a, [], 'Bucket Sort');
    return a;
  }

  async function mergeSort(arr) {
    stats.iter = 0;
    history = [];

    function merge(a, l, m, r) {
      const left = a.slice(l, m);
      const right = a.slice(m, r);
      let i = 0, j = 0;
      for (let k = l; k < r; k++) {
        updateSortStats('Merge Sort', k);
        if (j >= right.length || (i < left.length && left[i] <= right[j])) {
          a[k] = left[i++];
        } else {
          a[k] = right[j++];
        }
        recordState([...a], [k], 'Merge Sort', k);
      }
    }

    function sort(a, l, r) {
      if (r - l > 1) {
        const m = Math.floor((l + r) / 2);
        sort(a, l, m);
        sort(a, m, r);
        merge(a, l, m, r);
      }
    }

    let a = [...arr];
    sort(a, 0, a.length);
    recordState(a, [], 'Merge Sort');
    return a;
  }

  async function quickSort(arr) {
    stats.iter = 0;
    history = [];

    function sort(a, low, high) {
      if (low < high) {
        const pi = partition(a, low, high);
        sort(a, low, pi - 1);
        sort(a, pi + 1, high);
      }
    }

    function partition(a, low, high) {
      const pivot = a[high];
      let i = low;
      updateSortStats('Quick Sort', '', pivot);
      for (let j = low; j < high; j++) {
        updateSortStats('Quick Sort', j, pivot);
        if (a[j] < pivot) {
          [a[i], a[j]] = [a[j], a[i]];
          i++;
        }
        recordState([...a], [i, j], 'Quick Sort', j, pivot);
      }
      [a[i], a[high]] = [a[high], a[i]];
      recordState([...a], [i], 'Quick Sort', i, pivot);
      return i;
    }

    let a = [...arr];
    sort(a, 0, a.length - 1);
    recordState(a, [], 'Quick Sort');
    return a;
  }

  async function startSort() {
    data = parseInput();
    if (data.length === 0) return alert('Invalid input');
    const algo = document.getElementById('algorithm').value;
    stats.iter = 0;
    history = [];
    historyIndex = -1;
    isPlaying = false;
    updatePlayButton();

    switch (algo) {
      case 'bubble': await bubbleSort(data); break;
      case 'selection': await selectionSort(data); break;
      case 'insertion': await insertionSort(data); break;
      case 'bucket': await bucketSort(data); break;
      case 'merge': await mergeSort(data); break;
      case 'quick': await quickSort(data); break;
    }

    historyIndex = 0;
    drawFrame(0);
  }

  function playHistory() {
    clearInterval(playInterval);
    playInterval = setInterval(() => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        drawFrame(historyIndex);
      } else {
        clearInterval(playInterval);
        isPlaying = false;
        updatePlayButton();
      }
    }, delay);
  }
</script>


</body>

</html>
